# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from authzed.api.materialize.v0 import watchpermissions_pb2 as authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2


class WatchPermissionsServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.WatchPermissions = channel.unary_stream(
                '/authzed.api.materialize.v0.WatchPermissionsService/WatchPermissions',
                request_serializer=authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsRequest.SerializeToString,
                response_deserializer=authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsResponse.FromString,
                )


class WatchPermissionsServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def WatchPermissions(self, request, context):
        """WatchPermissions returns a stream of PermissionChange events for the given permissions.

        WatchPermissions is a long-running RPC, and will stream events until the client
        closes the connection or the server terminates the stream. The consumer is responsible of
        keeping track of the last seen revision and resuming the stream from that point in the event
        of disconnection or client-side restarts.

        The API does not offer a sharding mechanism and thus there should only be one consumer per target system.
        Implementing an active-active HA consumer setup over the same target system will require coordinating which
        revisions have been consumed in order to prevent transitioning to an inconsistent state.

        Usage of WatchPermissions requires to be explicitly enabled on the service, including the permissions to be
        watched. It requires more resources and is less performant than WatchPermissionsSets. It's usage
        is only recommended when performing the set intersections of WatchPermissionSets in the client side is not viable
        or there is a strict application requirement to use consume the computed permissions.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_WatchPermissionsServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'WatchPermissions': grpc.unary_stream_rpc_method_handler(
                    servicer.WatchPermissions,
                    request_deserializer=authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsRequest.FromString,
                    response_serializer=authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'authzed.api.materialize.v0.WatchPermissionsService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class WatchPermissionsService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def WatchPermissions(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/authzed.api.materialize.v0.WatchPermissionsService/WatchPermissions',
            authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsRequest.SerializeToString,
            authzed_dot_api_dot_materialize_dot_v0_dot_watchpermissions__pb2.WatchPermissionsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
