"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import authzed.api.v1.core_pb2
import authzed.api.v1.permission_service_pb2
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _WatchKind:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _WatchKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WatchKind.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    WATCH_KIND_UNSPECIFIED: _WatchKind.ValueType  # 0
    """Default, just relationship updates (for backwards compatibility)"""
    WATCH_KIND_INCLUDE_RELATIONSHIP_UPDATES: _WatchKind.ValueType  # 1
    WATCH_KIND_INCLUDE_SCHEMA_UPDATES: _WatchKind.ValueType  # 2
    WATCH_KIND_INCLUDE_CHECKPOINTS: _WatchKind.ValueType  # 3

class WatchKind(_WatchKind, metaclass=_WatchKindEnumTypeWrapper): ...

WATCH_KIND_UNSPECIFIED: WatchKind.ValueType  # 0
"""Default, just relationship updates (for backwards compatibility)"""
WATCH_KIND_INCLUDE_RELATIONSHIP_UPDATES: WatchKind.ValueType  # 1
WATCH_KIND_INCLUDE_SCHEMA_UPDATES: WatchKind.ValueType  # 2
WATCH_KIND_INCLUDE_CHECKPOINTS: WatchKind.ValueType  # 3
global___WatchKind = WatchKind

@typing.final
class WatchRequest(google.protobuf.message.Message):
    """WatchRequest specifies what mutations to watch for, and an optional start point for when to start
    watching.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPTIONAL_OBJECT_TYPES_FIELD_NUMBER: builtins.int
    OPTIONAL_START_CURSOR_FIELD_NUMBER: builtins.int
    OPTIONAL_RELATIONSHIP_FILTERS_FIELD_NUMBER: builtins.int
    OPTIONAL_UPDATE_KINDS_FIELD_NUMBER: builtins.int
    @property
    def optional_object_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """optional_object_types is a filter of resource object types to watch for relationship changes.
        If specified, only changes to the specified object types will be returned and
        optional_relationship_filters cannot be used.
        """

    @property
    def optional_start_cursor(self) -> authzed.api.v1.core_pb2.ZedToken:
        """optional_start_cursor is the ZedToken holding the point-in-time at
        which to start watching for changes.
        If not specified, the watch will start from the current SpiceDB revision time of the request ("head revision").
        Note that if this cursor references a point-in-time containing data
        that has been garbage collected, an error will be returned.
        """

    @property
    def optional_relationship_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[authzed.api.v1.permission_service_pb2.RelationshipFilter]:
        """optional_relationship_filters, if specified, indicates the
        filter(s) to apply to each relationship to be returned by watch.
        The relationship will be returned as long as at least one filter matches,
        this allows clients to match relationships on multiple filters on a single watch call.
        If specified, optional_object_types cannot be used.
        """

    @property
    def optional_update_kinds(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___WatchKind.ValueType]:
        """optional_update_kinds, if specified, indicates what kinds of mutations to include.
        If your SpiceDB instance is running behind a proxy that aborts idle connections,
        we recommend including Checkpoints to keep the stream alive even when there are no changes.
        """

    def __init__(
        self,
        *,
        optional_object_types: collections.abc.Iterable[builtins.str] | None = ...,
        optional_start_cursor: authzed.api.v1.core_pb2.ZedToken | None = ...,
        optional_relationship_filters: collections.abc.Iterable[authzed.api.v1.permission_service_pb2.RelationshipFilter] | None = ...,
        optional_update_kinds: collections.abc.Iterable[global___WatchKind.ValueType] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["optional_start_cursor", b"optional_start_cursor"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["optional_object_types", b"optional_object_types", "optional_relationship_filters", b"optional_relationship_filters", "optional_start_cursor", b"optional_start_cursor", "optional_update_kinds", b"optional_update_kinds"]) -> None: ...

global___WatchRequest = WatchRequest

@typing.final
class WatchResponse(google.protobuf.message.Message):
    """WatchResponse contains all mutation events in ascending timestamp order.
    This excludes relationships that were deleted because they expired.
    The response includes a field that can be used to resume
    watching from that point.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    UPDATES_FIELD_NUMBER: builtins.int
    CHANGES_THROUGH_FIELD_NUMBER: builtins.int
    OPTIONAL_TRANSACTION_METADATA_FIELD_NUMBER: builtins.int
    SCHEMA_UPDATED_FIELD_NUMBER: builtins.int
    IS_CHECKPOINT_FIELD_NUMBER: builtins.int
    FULL_REVISION_METADATA_FIELD_NUMBER: builtins.int
    schema_updated: builtins.bool
    """schema_updated, if true, indicates that the schema was changed in this revision."""
    is_checkpoint: builtins.bool
    """is_checkpoint, if true, indicates that a checkpoint was reached.
    A checkpoint indicates that the server guarantees that the client
    will not observe any changes at a revision below or equal to the revision in this response.
    """
    @property
    def updates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[authzed.api.v1.core_pb2.RelationshipUpdate]:
        """updates are the RelationshipUpdate events that have occurred since the
        call was made, or since the point in time specified by changes_through.
        """

    @property
    def changes_through(self) -> authzed.api.v1.core_pb2.ZedToken:
        """changes_through is the ZedToken that represents the point in time
        that the watch response is current through. This token can be used
        in a subsequent WatchRequest to resume watching from this point.
        """

    @property
    def optional_transaction_metadata(self) -> google.protobuf.struct_pb2.Struct:
        """optional_transaction_metadata is an optional field that returns the transaction metadata
        given to SpiceDB during the transaction that produced the changes in this response.
        This field may not exist if no transaction metadata was provided, or if multiple pieces
        of metadata were found during the transaction (in which case it is ambiguous which to return).
        """

    @property
    def full_revision_metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]:
        """full_revision_metadata contains all transaction metadata given to SpiceDB during the
        revision that produced the changes in this response. Some datastores (such as CockroachDB)
        can "merge" multiple transactions into a single revision (if the changes occurred concurrently),
        so this field is a list of all transaction metadata seen during the revision.
        """

    def __init__(
        self,
        *,
        updates: collections.abc.Iterable[authzed.api.v1.core_pb2.RelationshipUpdate] | None = ...,
        changes_through: authzed.api.v1.core_pb2.ZedToken | None = ...,
        optional_transaction_metadata: google.protobuf.struct_pb2.Struct | None = ...,
        schema_updated: builtins.bool = ...,
        is_checkpoint: builtins.bool = ...,
        full_revision_metadata: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["changes_through", b"changes_through", "optional_transaction_metadata", b"optional_transaction_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["changes_through", b"changes_through", "full_revision_metadata", b"full_revision_metadata", "is_checkpoint", b"is_checkpoint", "optional_transaction_metadata", b"optional_transaction_metadata", "schema_updated", b"schema_updated", "updates", b"updates"]) -> None: ...

global___WatchResponse = WatchResponse
