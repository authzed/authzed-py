"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import abc
import authzed.api.materialize.v0.watchpermissions_pb2
import collections.abc
import grpc
import grpc.aio
import typing

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

class WatchPermissionsServiceStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    WatchPermissions: grpc.UnaryStreamMultiCallable[
        authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsRequest,
        authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsResponse,
    ]
    """WatchPermissions returns a stream of PermissionChange events for the given permissions.

    WatchPermissions is a long-running RPC, and will stream events until the client
    closes the connection or the server terminates the stream. The consumer is responsible of
    keeping track of the last seen revision and resuming the stream from that point in the event
    of disconnection or client-side restarts.

    The API does not offer a sharding mechanism and thus there should only be one consumer per target system.
    Implementing an active-active HA consumer setup over the same target system will require coordinating which
    revisions have been consumed in order to prevent transitioning to an inconsistent state.

    Usage of WatchPermissions requires to be explicitly enabled on the service, including the permissions to be
    watched. It requires more resources and is less performant than WatchPermissionsSets. It's usage
    is only recommended when performing the set intersections of WatchPermissionSets in the client side is not viable
    or there is a strict application requirement to use consume the computed permissions.
    """

class WatchPermissionsServiceAsyncStub:
    WatchPermissions: grpc.aio.UnaryStreamMultiCallable[
        authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsRequest,
        authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsResponse,
    ]
    """WatchPermissions returns a stream of PermissionChange events for the given permissions.

    WatchPermissions is a long-running RPC, and will stream events until the client
    closes the connection or the server terminates the stream. The consumer is responsible of
    keeping track of the last seen revision and resuming the stream from that point in the event
    of disconnection or client-side restarts.

    The API does not offer a sharding mechanism and thus there should only be one consumer per target system.
    Implementing an active-active HA consumer setup over the same target system will require coordinating which
    revisions have been consumed in order to prevent transitioning to an inconsistent state.

    Usage of WatchPermissions requires to be explicitly enabled on the service, including the permissions to be
    watched. It requires more resources and is less performant than WatchPermissionsSets. It's usage
    is only recommended when performing the set intersections of WatchPermissionSets in the client side is not viable
    or there is a strict application requirement to use consume the computed permissions.
    """

class WatchPermissionsServiceServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def WatchPermissions(
        self,
        request: authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsResponse], collections.abc.AsyncIterator[authzed.api.materialize.v0.watchpermissions_pb2.WatchPermissionsResponse]]:
        """WatchPermissions returns a stream of PermissionChange events for the given permissions.

        WatchPermissions is a long-running RPC, and will stream events until the client
        closes the connection or the server terminates the stream. The consumer is responsible of
        keeping track of the last seen revision and resuming the stream from that point in the event
        of disconnection or client-side restarts.

        The API does not offer a sharding mechanism and thus there should only be one consumer per target system.
        Implementing an active-active HA consumer setup over the same target system will require coordinating which
        revisions have been consumed in order to prevent transitioning to an inconsistent state.

        Usage of WatchPermissions requires to be explicitly enabled on the service, including the permissions to be
        watched. It requires more resources and is less performant than WatchPermissionsSets. It's usage
        is only recommended when performing the set intersections of WatchPermissionSets in the client side is not viable
        or there is a strict application requirement to use consume the computed permissions.
        """

def add_WatchPermissionsServiceServicer_to_server(servicer: WatchPermissionsServiceServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
